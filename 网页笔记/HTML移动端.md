# 视口

## 简介

**视口(viewport)**就是浏览器显示页面内容的**屏幕区域**。视口可以分为布局视口、视觉视口和理想视口

## 布局视口 layout viewport

* 一般移动设备的浏览器默认设置了一个布局视口，用于解决早期的PC端页面的手机上显示问题
* ios,Android基本都将这个视口分辨设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。

## 视觉视口 visual viewport

* 字面意思，它是用户正看到的网站的区域，**注意：是网站的区域**
* 我们可以通过缩放去操作视觉视口，但不会影响布视口，布局视口仍保持原来的宽度

## 理想视口 ideal viewport

* 为了使网站在移动端有最理想的浏览和阅读宽而设定
* 理想视口，对设备来讲，是最理想的视口尺寸
* 需要手动添写`mrta`视口标签通知浏览器操作
* `mrta`视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我的布局的视口就有多宽

### meta视口标签

```css
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0 minimum-scale=1.0">
/*
viewport：视口标签
width=device-width：宽度等于设备的宽度
user-scalable=no：用户是否要缩放,no。不允许用户缩放
initial-scale=1.0：网面打开按照原来的大小显示，2是两倍
*/
```



| 属性           | 解释说明                                         |
| -------------- | ------------------------------------------------ |
| width          | 宽度设置viewport宽度，可以设置device-width特殊值 |
| initial-scale  | 初始缩放比，大于0的数字                          |
| maximum-scale  | 最大缩放比，大于0的数字                          |
| minimum-sclale | 最小缩放比，大于0的数字                          |
| user-scalable  | 用户是否可以缩放，yes或no(1或0)                  |

## 标准的viewport设置

* 视口宽度和设备保持一致
* 视口的默认缩放比例1.0
* 不允许用户自行缩放
* 最大允许的缩放比例1.0
* 最小允许的缩放比例1.0

# 二倍图

## 物理像素&物理像素比

* 物理像素点指的是屏幕显示最小颗粒，是物理真实存在。这是厂商在出厂就设置好了，比如苹果6\7\8 是750*1334
* 我们开发时候的1px不是一定等于1物理像素的
* PC端页面，1px等于1物理像素的，但移动端不尽相同，有的是1px==2px
* 一个px的能显示的物理像素点的个数，称为物理素比或屏幕像素比

### 解释

* PC端和早前的手机屏幕/普通手机屏幕：1CSS像素==1物理像素的
* Retina(视网膜屏幕)是一种显示技术，可以将把更多的物理像素压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。

## 多倍图

* 对于一张50px*50px的图片，在手机Retina屏中打开，按照刚的物理像素比会放大倍数，这样会造成图片模糊
* 在标准的viewport设置中，使用倍图来提高图片质量，解决高清设备中的模糊问题
* 通常使用二位图，因为iPhone6\7\8的影响，但是还存在3倍图4倍图的情况，这个看实际开发公司需求
* 背景图片 注意缩放问题

```css
img {
    /* 原始图片100*100px */
    width: 50px;
    height: 50px;
}
.box {
    /* 原始图片100*100px */
    background-size: 50px 50px;
}
```

### 背景缩放 background-size

```css
/* 1. background-size: 图片宽度 图片高度 */
background-size: 200px 300px;
/* 2. 只写一个参数肯业是宽度 高度省略 等比例缩放 */
background-size: 200px;
/* 3. 单位可以是 % 相对于父盒子来说的 不是图片本的百分比 */
background-size: 50%;
/* 4. cover等比例伸 要完全覆盖div盒子 宽度和高度都要与盒子一样大 图片可能显示不全*/
barckground-size: cover;
/* 5. contain 宽度和高度等比例伸 当宽度或者高度铺满div盒子就不再进行拉伸了 可能有部分空白区域 */
barckground-size: contain;
```

* 单位：长度|百分比|cover|contain;
* cover把背景图像扩展至足够大，以使背景完全覆盖背景区域
* contain把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域

# 移动端技术选型

## 移动端布局和以前我们学习的PC端有所区别

### 1. 单独制作移动端页面(主流)

* 流式布局(百分比布局)
* flex弹性布局(强烈推荐)
* less+rem+媒体查询布局
* 混合布局

### 2. 响应式页面兼容移动端(其次)

* 媒体查询
* bootstarp

## 流式布局(百分比布局)

* 流式布局，就是百分比布局，也称非固定像素布局
* 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素限制，内容向两侧填充。
* 流式布局方式是移动web开发使用的比较常见布局方式。
* max-width：最大宽度(max-height最大高度)
* min-width：最小宽度(min-height最小高度)

# flex布局

## 传统布局与flex布局

**传统布局**

* 兼容性好
* 布局繁琐
* 局限性，不能再移动端很好的布局

**flex 弹性布局**

* 操作方便，布避极为简单，移动端应用很广泛
* PC端浏览器支持情况较差
* IE 11或更抵版本，不支持仅部分支持

**建议**

> * 如果是PC端页面布局，我们还是传统布局
> * 如果是移动端或者不考虑兼容性问题的PC端页面布局，我们还是使用flex弹性布局

## flex盒子的布局原理

## 简介

flex是flexble Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局

* 当我们为盒子设为fiex布局以后，子元素的float，claer和`vertical-align`属性将失效
* 伸缩布局=弹性布局=伸缩缩盒布局=弹性盒布局=flex布局

采用Flex布局的元素，称为Flex容器(flex container)，简称容器。它的所有子元素自动成容器成员，称为Flex项目(flex item)，简称“项目”

* 体验div就是flex父容器
* 体验中span就是子容器flex项目
* 子容器可以横向排列也可以纵向排列

**总结flex布局原理**

> 就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式

# 使用flex布局的常用属性

## flex布局父项常见属性

### 常见父项属性

* **`flex-direction`**：设置主轴的方向
* **`justify-content`**：设置主轴上的子元素排列方式
* **`flex-wrap`**：设置子元素是否换行
* **`align-content`**：设置侧轴上的子元素的排列方式(多行)
* **`align-items`**：设置侧轴的子元素排列方式(单行)
* **`flex-flow`**：复合属性，相当于同时设置`flex-direction`和`flex-wrap`。

### flex-direction 设置主轴的方向

#### 1. 主轴与侧轴

在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴

* 默认主轴方向说是x轴方向，水平向右
* 默认侧轴方向就是y轴方向，水平向下

#### 2. 属性值

`flex-direction`属性决定主轴的方向(即项目的排列方向)

注意：主轴和侧轴是会变化的，就看`flex-dirction`设置谁为主轴，剩下的就是侧轴。而我们的子素元素跟着主轴来排列的

| 属性值         | 说明           |
| -------------- | -------------- |
| row            | 默认值从左到右 |
| row-reverse    | 从右到左       |
| column         | 从上到下       |
| column-reverse | 从下到上       |

### justify-content 设置主轴上的子元素排列方式

`justify-content`属性定义了项目在主轴上的对齐方式

**注意：使用这个属性之前一定要确定好主轴是哪个**

| 属性值        | 说明                                                       |
| ------------- | ---------------------------------------------------------- |
| flex-start    | 默认值从头部开始 如果主轴是x轴，则从左到右                 |
| flex-end      | 从尾部开始排列                                             |
| center        | 在主轴居中对齐(如果主轴是x轴则 水平居中)，侧轴不会跟着居中 |
| space-around  | 平分剩空间                                                 |
| space-between | 先两边贴边再平分剩余空间(重要)                             |

### aingn-items 设置侧轴上的子元素排列方式(单行)

该属性是控制子项在侧轴(默认是y轴)上的排列方式 在子项单项的时候使用，

> 侧轴不代表它是就是y轴，只是默认y轴为侧轴

| 属性值     | 说明                   |
| ---------- | ---------------------- |
| flex-start | 从上到下               |
| flex-end   | 从下到上               |
| center     | 挤在一起居中(垂直居中) |
| stretch    | 拉伸(默认值)           |

###  flex-wrap设置子元是否换行

默认情况下，项目都排在一条线(又称“轴线”)上。flex-wrap属性定义，flex布局中默认不换行的

| 属性值 | 说明           |
| ------ | -------------- |
| nowrap | 默认值，不换行 |
| wrap   | 换行           |

### align-content设置侧轴上的子元素的排列方式(多行)

设置子项在侧轴上的排列方式并且只能用于子项出现**换行**的情况(多行)，在单行下是没有效果的。

| 属性值        | 说明                                                     |
| ------------- | -------------------------------------------------------- |
| flex-start    | 默认值在侧轴的头部开始排列                               |
| flex-end      | 在侧轴的尾部开始排列                                     |
| center        | 在侧轴中间显示                                           |
| space-around  | 子项在侧轴平分剩余空间                                   |
| space-between | 子项在侧轴先分布在两头，再平分剩余空间                   |
| stretch       | 设置子项元素高度平分父元素高度，如果子项有高度则不起效果 |

#### alingn-content和align-items区别

* `align-items`适用于单行情况下，只有上对齐，下对齐，居中和拉伸
* `align-content`适应于**换行**(多行)的情况下(单行情况无效)，可以设置上对齐、下对齐、居中、拉伸以及平均分配余空间等属性值
* **总结就是单行找`align-items` 多行找`align-content`**

### flex-flow

`flex-flow`属性是`flex-direction`和`flex-wrap`属性的复合属性

```css
flex-flow: row wrap;
```

* flex-direction：设置主轴的方向
* justify-content：设置主轴的子元素排列方式
* flex-wrap：设置子元素是否换行
* align-content：设置侧轴上的子元素的排列方式(多行)
* alingn-items：设置侧轴上的子元素排列方式(单行)
* flex-flow：复合属性，相当于同时属设置了`flex-direction`和`flex-wrap`.

## flex布局子项常见属性

### 常见属性

* `flex`子项目占的份数
* `align-self`控制子项自己在侧轴的排列方式
* `order`属性定义子项的排列顺序(前后顺序)

### flex属性

`flex`属性定义子项目分配剩余空间，用flex来表示占多少**份数**。

> 如果子项目设有高和宽的话，就从这个子项目剩余空间里去分配份数

```css
.item {
    flex: <number>; /* 默认是0 */
    /* number数字 */
}
```

### align-self控制子项自己在侧轴上的排列方式

`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。

默认值auto，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

**跟父级的属性一致**

```css
span:nth-child(2) {
    /* 设置自己在侧轴上的排列方式 */
    align-self: flex-end;
}
```

### order 属性定义项目排列顺序

数值越小，排列越靠前，默认为0。也就是自己当前位置是0，向前移是负值

注意：和z-index不一样。

# 背景渐变

## 背景线性渐变

**语法**

```css
background: linear-gradient(起始方向,颜色1，颜色2,...);
/* 背景渐变必须添加浏览器私有前缀 */
background: -webkit-linear-gradient(left, red,blue);
background: -webkit-linear-gradient(left,top,red,blue);
```

背景渐变必须添加浏览私有前缀

起始方向可以是：方位名 或者 度数，如果省默认就是top

# rem适配布局

## rem基础

### rem单位

rem(root em)是一个相对单位,类似于于em,em是父元素字体大小

不同的是`rem`的基准是相对于**html**元素的字体大小

这如,根元素(html)设置`font-size=12px`,非根元素设置`width: 2rem;`则换成px就是24px

**em是相对父元素的字体大小**

> ```css
> <html>
> <head>
> 	<style>
> 		div {
>     		font-size: 12px
> 		}
> 		p {
> 		    width: 10em;
>     			height: 10em;
>             /*
>            	 	此时的p相对于父元素字体大小
>             	12px*10  大小是120px
>             */
>             background-color: red;
> 		}
> 	</style>
> </head>
> <body>
> 	<div>
> 		<p></p>	
> 	</div>
> </body>
> </html>
> ```

## 媒体查询

### 什么是媒体查询

媒体查询(Media Query)是css3新语法

* 使用**`@media`**,可以针对不同的媒体类型定义不同的样式
* **`@media`可以针对不同的屏幕尺寸设置不同的样式**
* 当你重置浏览器大小过程中,页面也会根据浏览器的宽度和高度重新渲染页面
* 目前针对很多苹果手机、Android手机、平板等设备都用得到多媒体查询

### 语法

```css
@media mediatype and|not|only (media feature) {
    css code;
}
```

* 用`@medid`开头 注意@符号
* mediatype媒类型
* 关键字and not only
* medid feature 媒体特性 必须有小括号包含

**mediatype查询类型**

| 值     | 说明                               |
| ------ | ---------------------------------- |
| all    | 用于所有设备                       |
| print  | 用于打印机和打印预览               |
| screen | 用于电脑屏幕、平板电脑、智能手机等 |

**关键字**

* and：可以将多个媒体特性连接到一起，相当于 "且" 的意思。
* not：排除某个媒体类型，相当于 ”非“ 的意思，可以省略
* only：指定某个特定的媒体类型，可以省略。

**媒体特性**

每种媒体类型都 具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。**注意它们要加小括号包含**

| 值        | 说明                               |
| :-------- | ---------------------------------- |
| width     | 定义输出设备中页面可见区域的宽度   |
| min-width | 定义输出设备中页面最小可见区域宽度 |
| max-width | 定义输出设备中页面最大可见区域宽度 |

 **例**

```css
/* 这句话的意思就是: 在我们屏幕上 并且最的宽度是800px */
/* max-width: 小于等800 */
@media screen and (max-width: 800px) {
    body {
        background-color: pink;
    }
}
@media screen and (max-width: 500px) {
    body {
		background-color: purple;
    }
}
```

> `min-width: 800px`：这个页面最小值是800px才改能执行下面的规定的值，一但这个页面小于800px就不在执行规定的值。可以理解为大于800px
>
> `max-width: 800px`：这个页面一但超过800px不会执行规定的值，只在800px范围内，可以理解为**小于(<)**,只在媒体查询里

## 引入资源

当样式比较繁多的时候，我们可以针不同的媒体使用不同`stylesheets`(样式表)。

原理，就是直接在link中判断设备的尺寸，然后引入不同的css文件

**语法规范**

```css
<link rel="stylesheet" media="mediatype and|not|only (media feature)" href="样式.css">
```

# Less基础

## 维护 css 的弊端

css是一非程序式语言，没有变量、函数、SCOPE(作用域)等概念。

* css需要书写大量看似没有逻辑的代码，css冗余度是比较高的。
*  不方便维度及扩展，不利于复用
* css没有很好的计算能力
* 非前端开发工程师来讲，往往会因为缺少ccs编经验而很难写出组织良好的且易于维护的css代码项目。

## Less介绍

Less(Leaner Style Sheets的缩写)是一门css扩展语言，也成为css预处理器。

做为css的一种形式的扩展，它并没有减少css的功能，而是在现有的css语法上，为css加入程序式语言的特性。

它在css的语法基础之上，引入了变量，Mixin(混入)，运算以及函数等功能，大大简化了css的编写，并且降低了css的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。

Less是中文网址：<http://lesscss.cn/>

常见的css预处理器：Sass、Less、Stylus

**Less是一门CSS预处理语言，它扩展了CSS的动态特性**

## Less使用

### 学习的内容有：

我们首新建个一后缀名为less的文件，在这个less文件里面书写less语句。

* Less 变量
* Less 编译
* Less 嵌套
* Less 运算

### Less 变量

变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用

```less
@变量名: 值;
```

**变量命名规范**

* 必须有@为前缀
* 不能包含特殊字符
* 不能以数字开头
* 大小写敏感

**例** 

```less
@color: red;
@font14: 14px;
body {
    barckground-color: @color;
}
div  {
    color: @color;
}
a {
    font-size: @font14;
}
```

### Less 编译

本质上，Less包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生对应的CSS文件。

所以，我们需要把们的less文件，编译生成为css文件，这样我们的html页面才能使用

### Less 嵌套

#### 常用到选择器的嵌套

```less
.header .logo {
    width: 300px;
}
```

**Less嵌套写法**

```less
.header {
     // less嵌套 子元素的样式直接写到父元素里就好了
    .logo {
        width: 300px;
    }
}
```

#### 如果遇见(交集|伪类|伪元素选择器)

* 内层选择器的前面没有&符号，则它被解析父选择器后代
* 如果有&符号，它就被 解析为你父元素或父元素的伪类。

```css
a:hover {
    color: red;
}
```

**Less嵌套写法**

```less
a {
    &:hover {
        color: red;
    }
}
```

### Less 运算

####  简介

任何数字、颜色或者变量都可以参与运算。就是Less提供了加(+)、减(-)、乘(*)、除(/)算术运算

```less
//Less里面写
//要有空格
@width: 10px + 5;
div {
    border: @width solid red;
}
// 生成的css 
div {
    border: 15px solid red;
}
//Less 甚至还可以这样
width： (@width + 5) * 2;
```

**注意**

> * **运算符中间左右有空格隔开1px + 5**
> * 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位
> * 如果两个值之间只有一个值有单位，则运算结果就取该单位

### less 导入文件

```less
@import "common";
// @import 导入的意思 可以把一样式文件导入到另外出一样式文件里面
//link 是把样式文件引入到html页面里面
```





# rem适配方案

## rem适配方案

1. 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备
2. 使用媒体查询根椐不同设备按比例设置html的字体，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配

## rem实际开发适配方案

* 按照设计稿与设备宽度的比例，动态计算并设置html根标签font-size大小;(媒体查询)
* CSS中，设计稿元素的宽、高相对位置等取值，按照同等比例换算为rem为单位的值;

## rem适配方案技术使用(市场主流)

**技术方案**

* less
* 媒体查询
* rem

**技术方案2(推荐)**

* flexible.js
* rem

**总结**

> 1. 两种方案现在都存在。
> 2. 方案2 更简单

## rem实际开发适配方案1

### 设计稿常见尺寸宽度

| 设备           | 常见度度                                                     |
| -------------- | ------------------------------------------------------------ |
| iphone4.5      | 640px                                                        |
| iphone 6、7、8 | 750px                                                        |
| Android        | 常见320px、360px、375px、384px、400px、414px、500px、720px，大部分4.7~5寸的安桌设备为720px |

一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其降级，牺性一些效果，**现在基本以750为准**

### 动态设置html标签font-size大小

* 假设设计稿是750px，以750px为准，其它大小按照750等比缩放
* 假设我们把整个屏幕划分为15等份(划分标准不一可以是20份也可以是10等份)
* 每一份作为html字体大小，这里就是50px
* 那么在320px设备的时候，字体大小为320/15就是21.33px
* 用我们页面元素的大小 除不同的html字体大小会发现他们比例还是相同的
* 比如我们以750为标准设计稿
* 一个100*100像素的页面元素在750屏幕下，就是100/50转换为rem是 2rem * 2rem 比例是 1比1
* 320屏幕下，html字体大小为21.33 则2rem == 42.66px 此时宽和高都是42.66 但是 宽和高的比例还是 1比1
* 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果

### 元素大小取值方法

* 最后的公式：页面元素的rem值 = 页面元素值(px) / (屏幕宽度 / 划分的份数)
* 屏幕宽度 / 划分的份数 就是 html font-size的大小
* 或者：页面元素的rem值 = 页面元素值(px) / html font-size 字体大小

#### 例

```less
//设置常见的屏幕尺寸 修改里的html文字大小
//320 
//我们此次定义的划分的份数 为15
//推荐从小到大写
@num: 15;
@media screen and (min-width: 320px) {
    html {
        font-size: 320px / @num;
    }
}
//360
@media screen and (min-width: 360px) {
    html {
        font-size: 360px / @num;
    }
}
//375 iphone678 只在是屏幕小于375px字体不再是375 / @num;大小
@media screen and (min-width: 375px) {
    html {
        font-size: 375px / @num;
    }
}
```

## rem 适配方案2

### 简洁高效的rem适配方案flexible.js

手机淘宝团队出的简洁高效 移动端适配库

我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理

它的原理是把当前设备划分10等份，但不同的设备，比例还是一致的

我们要做的，就是确定好我们当前设备的html文字大小就可以了

比如当前设计稿750px，那么我们只需要把html文字大设置75px(750px/10)就可以

里面页面元素rem值：页面元素的px值/75

剩余，让flexble.js来去算

> 它会把页面除以10，把得到的结果当作根字体
>
> 例如：
>
> 当页面是375px，那么html的字体大小就是37.5px

github地址：<https://github.com/amfe/lib-flexible>

# 移动web开发响应式布局

## 响应式开发原理

就是使用媒体查询对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。

| 设备划分                 | 尺寸区间            |
| ------------------------ | ------------------- |
| 超小屏幕                 | < 768px             |
| 小屏设备（平板）         | >=768 ~ < 992px     |
| 中等屏幕（桌面显示器）   | >= 992px ~ < 1200px |
| 宽屏设备（大桌面显示器） | >= 1200px           |

## 响应式布局容器

响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果

原理就是在不同屏幕下，通过媒体查询来改变这个布局的大小，再改变里面子元素的排列方和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化

**平时我们的响应式尺寸划分**

* 超小屏幕（手机，小于768px）：设置宽度为100%
* 小屏幕（平板，大于等于768px）：设置宽度为750px
* 中等屏幕（桌面显示器，大于等于992px）：宽度设置为970px
* 大屏幕（大桌面显示器，大于等于1200px）：宽度设置为1170px

## Bootstrap前端开发框架

### Bootstrap 简介

Bootstrap来自Twitter(推特)，是目前最受欢迎的前端架。Bootstrap是基于HTML、CSS和js的，它简洁灵活，**使得wbe开发更加快捷。**

* 中文官网：<https://www.bootcss.com/>
* 官网：<https://www.getbootstrap.com/>
* 推荐使用：<http://bootstrap.css88.com/>

**框架：**顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发























































































